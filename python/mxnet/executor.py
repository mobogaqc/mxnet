# coding: utf-8
# pylint: disable=invalid-name, protected-access, too-many-locals, fixme
""" code for executor. """
from __future__ import absolute_import

import ctypes
from .base import _LIB
from .base import mx_uint, NDArrayHandle, ExecutorHandle
from .base import check_call, c_array, py_str
from .ndarray import NDArray

class Executor(object):
    """ Executor is the actual executing object of MXNet."""
    def __init__(self, handle):
        """Init an executor from handle

        Parameters
        ----------
        handle: ExecutorHandle
            ExecutorHandle generated by calling Bind
        """
        if not isinstance(handle, ExecutorHandle):
            raise TypeError("Handle type error")
        self.handle = handle
        self.arg_arrays = []
        self.grad_arrays = []
        self.aux_arrays = []
        self.outputs = self._get_outputs()

    def forward(self, is_train=True):
        """Do forward.

        Parameters
        ----------
        is_train: bool
            whether this forward is for evaluation purpose
        """
        check_call(_LIB.MXExecutorForward(
            self.handle,
            ctypes.c_int(int(is_train))))

    def backward(self, head_grads=None):
        """Do backward on heads' gradient.

        Parameters
        ----------
        head_grads : NDArray or list of NDArray, optional
            Gradient on the heads
        """
        if head_grads is None:
            head_grads = []
        elif isinstance(head_grads, NDArray):
            head_grads = [head_grads]

        for obj in head_grads:
            if not isinstance(obj, NDArray):
                raise TypeError("inputs must be NDArray")
        ndarray = c_array(NDArrayHandle, [item.handle for item in head_grads])
        check_call(_LIB.MXExecutorBackward(
            self.handle,
            mx_uint(len(head_grads)),
            ndarray))

    def debug_str(self):
        """Get a debug string about internal execution plan.

        Returns
        -------
        debug_str : string
            Debug string of the executor.
        """
        debug_str = ctypes.c_char_p()
        check_call(_LIB.MXExecutorPrint(
            self.handle, ctypes.byref(debug_str)))
        return py_str(debug_str.value)

    def _get_outputs(self):
        """list all heads' output ndarray

        Returns
        -------
        A list of ndarray binded to the heads of executor.
        """
        out_size = mx_uint()
        handles = ctypes.POINTER(NDArrayHandle)()
        check_call(_LIB.MXExecutorOutputs(self.handle,
                                          ctypes.byref(out_size), ctypes.byref(handles)))
        return [NDArray(NDArrayHandle(handles[i])) for i in range(out_size.value)]
