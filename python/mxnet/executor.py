# coding: utf-8
# pylint: disable=invalid-name, protected-access, too-many-locals, fixme
""" code for executor. """
from __future__ import absolute_import

import ctypes
from .base import _LIB
from .base import c_array, mx_uint, NDArrayHandle, ExecutorHandle
from .base import check_call
from .ndarray import NDArray

class Executor(object):
    """ Executor is the actual executing object of MXNet."""
    def __init__(self, handle):
        """Init an executor from handle

        Parameters
        ----------
        handle: ExecutorHandle
            ExecutorHandle generated by calling Bind
        """
        if not isinstance(handle, ExecutorHandle):
            raise TypeError("Handle type error")
        self.handle = handle
        self.arg_ndarrays = []
        self.grad_ndarrays = []
        self.auxiliary_states = []

    def list_arguments(self, with_grad=True):
        """Return arguments (and grad for arguments)

        Parameters
        ----------
        with_grad: bool
            whether return args with grad

        Returns
        -------
            if with_grad = True, return (args, grad) pair list
            otherwise return args list only
            Note: args sequence is same to symbol.list_arguments()
        """
        if with_grad:
            return self.arg_ndarrays, self.grad_ndarrays
        else:
            return self.arg_ndarrays

    def list_auxiliary_states(self):
        """Return auxiliary states of executor
            Note: auxiliary states is same to symbol.list_auxiliary_states()
        """
        return self.auxiliary_states

    def forward(self, is_train=True):
        """Do forward.

        Parameters
        ----------
        is_train: bool
            whether this forward is for evaluation purpose
            Note: for test only network, please indicate in Bind (TODO)
        """
        check_call(_LIB.MXExecutorForward(self.handle, is_train))

    def backward(self, head_grads=None):
        """Do backward on heads' gradient.

        Parameters
        ----------
        head_grads : NDArray or list of NDArray, optional
            Gradient on the heads
        """
        if head_grads is None:
            head_grads = []
        elif isinstance(head_grads, NDArray):
            head_grads = [head_grads]

        for obj in head_grads:
            if not isinstance(obj, NDArray):
                raise TypeError("inputs must be NDArray")
        ndarray = c_array(NDArrayHandle, [item.handle for item in head_grads])
        check_call(_LIB.MXExecutorBackward(self.handle, len(head_grads), ndarray))

    def heads(self):
        """list all heads' output ndarray

        Returns
        -------
        A list of ndarray binded to the heads of executor.
        """
        # TODO: think of access, make heads read only.
        # (consider support read only NDArray(NDArrayView))
        # Otherwise some of the internal might depends on out_data
        # if user set the content of the head, the backward behavior can be incorrect.
        out_size = mx_uint()
        handles = ctypes.POINTER(NDArrayHandle)()
        check_call(_LIB.MXExecutorHeads(self.handle, ctypes.byref(out_size), ctypes.byref(handles)))
        return [NDArray(NDArrayHandle(handles[i])) for i in range(out_size.value)]
